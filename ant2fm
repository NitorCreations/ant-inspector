#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use Carp; $SIG{ __DIE__ } = sub { Carp::confess( @_ ) }; # die now prints stacktrace

use XML::Easy::Text qw( xml10_read_document xml10_write_element );
use File::Spec;

sub slurp($) {
    undef $/;
    open F, '<', $_[0] or die $_[0];
    my $file = <F>;
    close F;
    return $file;
}

sub slurpxml($) {
    return xml10_read_document(slurp($_[0]));
}

sub children($) {
    my @children;
    my $arr = $_[0]->content_twine;
    for (my $i=1; $i<=$#$arr; $i+=2) {
	push @children, $arr->[$i];
    }
    return \@children;
}

sub resolve($$) {
    my ($a, $property) = @_;
    my $res = $a->{properties}->{$property};
#    die $property unless(defined($res));
#    print "resolve $property = $res\n";
    return $res;
}

sub expand($$) {
    my ($a,$x) = @_;
    die unless(defined($a) && defined($x));
#    print "expand $x\n";
#    1 while ($x =~ s!(\$\{([^\$\}]+)\})!my $r=resolve($a, $2);defined($r)?$r:$1!ge);
    $x =~ s!(\$\{([^\$\}]+)\})!my $r=resolve($a, $2);defined($r)?$r:$1!ge;
#    print "expand $_[1] = $x\n";
    return $x;
}

sub parseTarget($$) {
    my ($a, $elem) = @_;
    return { file => $a->{file}, deps => $elem->attribute("depends"), steps => children($elem) };
}

sub parseMacro($$) {
    my ($a, $elem) = @_;
    my @attrs;
    my $sequential;
    foreach my $elem (@{children($elem)}) {
	my $name  = $elem->type_name;
	if ($name eq 'attribute') {
	    push @attrs, $elem->attribute("name");
	} elsif ($name eq 'sequential') {
	    die if(defined($sequential));
	    $sequential = children($elem);
	}
    }

    return { file => $a->{file}, attributes => \@attrs, steps => $sequential };
}

sub dirof($) {
    my $x = $_[0];
    return $x =~ s!/[^/]+$!! ? $x : '.';
}

sub merge($$$) {
    my ($d,$dk,$s) = @_;
    foreach my $k (keys(%$s)) {
	unless(defined($d->{$dk}->{$k})) {
	    $d->{$dk}->{$k} = $s->{$k};
	}
    }
}

sub runSteps($$$);

sub parse($$$);
sub parse($$$) {
    my $file = $_[0];
    my $parent = $_[1];
    my $globalProperties = $_[2];

    $file = File::Spec->rel2abs($file);

    my $a = {};

    $a->{file} = $file;

    #print "=== PARSING $file ===\n";
    my $xml = slurpxml($file);

    if (defined($parent)) {
	$a->{properties} = $parent->{properties};
	$a->{steps} = $parent->{steps};
    } else {
	$a->{properties} = { %$globalProperties };
	$a->{properties}->{"ant.file"} = $file;
	$a->{properties}->{"basedir"} = File::Spec->rel2abs($xml->attribute("basedir") || dirof($file));
	$a->{properties}->{"ant.project.default-target"} = $xml->attribute("default");
    }

    my $projectName = $xml->attribute("name");
    if(defined($projectName)) {
	$a->{properties}->{"ant.file.".$projectName} = $file;
	$a->{properties}->{"ant.project.name"} = $projectName;
    }

    runSteps($a, children($xml), undef);

    return $a;
}

my @icons = qw(idea help yes messagebox_warning stop-sign closed info button_ok button_cancel full-1 full-2 full-3 full-4 full-5 full-6 full-7 full-8 full-9 full-0 stop prepare go back forward up down attach ksmiletris smiley-neutral smiley-oh smiley-angry smily_bad clanbomber desktop_new gohome folder korn Mail kmail list edit kaddressbook knotify password pencil wizard xmag bell bookmark penguin licq freemind_butterfly broken-line calendar clock hourglass launch flag-black flag-blue flag-green flag-orange flag-pink flag flag-yellow family female1 female2 male1 male2 fema group);

my %typeIcons;
my $typeIconCount = 0;
foreach my $type (qw(target child arg)) {
    $typeIcons{$type} = $icons[$typeIconCount++];
}

$typeIcons{'step'} = 'forward';

sub xe($) {
    my $s = $_[0];
    $s =~ s!&!\&amp;!g;
    $s =~ s!\"!\&quot;!g;
    $s =~ s!<!\&lt;!g;
    $s =~ s!>!\&gt;!g;
    return $s;
}

sub resolveArg($$) {
    my ($args, $property) = @_;
    my $res = $args->{$property};
    return $res;
}

sub expandArg($$$) {
    my ($a,$args,$x) = @_;
    $x = expand($a,$x);
    $x =~ s!(\@\{([^\$\}]+)\})!my $r=resolveArg($args, $2);defined($r)?$r:$1!ge if (defined($args));
    return $x;
}

sub printArg($$$$) {
    my ($a,$args,$arg,$val) = @_;
    my $expanded = expandArg($a, $args, $val);
    print '<node TEXT="',xe($arg.' = '.$val.($val eq $expanded ? '' : ' => '.$expanded)),'">';
    print '<icon BUILTIN="',$typeIcons{arg},'"/>';
    print '</node>';
}

sub printChild($) {
    my ($child) = @_;
    print '<node TEXT="',xe(xml10_write_element($child)),'">';
    print '<icon BUILTIN="',$typeIcons{child},'"/>';
    print '</node>';
}

sub runSteps($$$) {
    my ($a, $steps, $args) = @_;

    ## TODO $a->{file} references are wrong after target execution starts
 
    foreach my $step (@$steps) {
	my $name = $step->type_name;
	if ($name eq "import") {
	    my $importfile = expandArg($a, $args, $step->attribute("file"));
	    $importfile = dirof($a->{file}) . '/' . $importfile unless($importfile =~ m!^/!);
	    my $imported = parse($importfile, $a, undef);
	    push @{$a->{imports}}, $imported;
	    #print "=== DONE $importfile, RESUMING $a->{file} ===\n";
	} elsif ($name eq "property") {
	    my $propprefix = "";
	    my $propsuffix = "";
	    if (defined($step->attribute("name"))) {
		my $propname = $step->attribute("name");
		my $propval = $step->attribute("value") || $step->attribute("location") or die Dumper($step);
		my $expanded = expandArg($a, $args, $propval);
		if (!defined($a->{properties}->{$propname})) {
		    #print "Define property ",$propname," = ",$propval," => ",$expanded,"\n";
		    $a->{properties}->{$propname} = $expanded;
		} elsif ($a->{properties}->{$propname} eq $expanded) {
		    $propprefix = "REDUNDANT ";
		} else {
		    #print "Ignore property definition ",$propname," = ",$propval,"\n";
		    $propprefix = "IGNORED ";
		    $propsuffix = ", retaining value ".$a->{properties}->{$propname};
		}
		print '<node TEXT="',xe($propprefix.'setProperty '.$propname.' = '.$propval.($propval eq $expanded ? '' : ' => '.$expanded).$propsuffix),'">';
		print '<icon BUILTIN="',$typeIcons{step},'"/>';
		print '</node>';
	    } elsif (defined($step->attribute("environment"))) {
		my $envprefix = $step->attribute("environment").".";
		$a->{properties}->{$envprefix.'HOSTNAME'} = "__HOSTNAME__";
	    }

	} elsif ($name eq "target") {
	    $a->{targets}->{$step->attribute("name")} = parseTarget($a, $step);
	} elsif ($name eq "macrodef") {
	    $a->{macros}->{$step->attribute("name")} = parseMacro($a, $step);
	} elsif ($name eq "description") {
	} elsif ($name eq "taskdef") {
	} elsif ($name eq "scriptdef") {
	} elsif ($name eq "path") {
	} elsif ($name eq 'ant') {
	    my $file = $step->attribute('antfile');
	    print '<node TEXT="ant ',xe($file),'">';
	    print '<icon BUILTIN="',$typeIcons{step},'"/>';
	    $file = $a->{properties}->{"basedir"}.'/'.$file unless($file =~ m!^/!);
	    my $subAnt = parse($file, undef, {});
	    run($subAnt, $step->attribute('target'));
	    print '</node>';
	} elsif ($name eq 'if') {
	    # TODO ifelse
	    my $then;
	    my $else;
	    my $condition;
	    foreach my $child (@{children($step)}) {
		my $n = $child->type_name;
		if ($n eq 'then') {
		    $then = children($child);
		} elsif($n eq 'else') {
		    $else = children($child);
		} elsif($n eq 'equals') {
		    $condition = 'equals("'.$child->attribute('arg1').'","'.$child->attribute('arg2').'")';
		} elsif($n eq 'available') {
		    $condition = 'available("'.$child->attribute('file').'","'.$child->attribute('type').'")';
		} elsif($n eq 'istrue') {
		    $condition = 'istrue('.$child->attribute('value').')';
		} else {
		    die "Unsupported condition:".Dumper($child);
		}
	    }

	    my $expanded = expandArg($a, $args, $condition);
	    print '<node TEXT="if ',xe($condition.($condition eq $expanded ? '' : ' => '.$expanded)),'">';
	    print '<node TEXT="then">';
	    runSteps($a, $then, $args);
	    print '</node>';
	    if(defined($else)) {
		print '<node TEXT="else">';
		runSteps($a, $else, $args);
		print '</node>';
	    }
	    print '</node>';
	} elsif ($name eq 'for') {
	    print '<node TEXT="for ',xe($step->attribute('param')),'">';
	    print '<icon BUILTIN="',$typeIcons{step},'"/>';
	    foreach my $arg (keys %{$step->attributes}) {
		next if($arg eq 'param');
		printArg($a,$args,$arg,$step->attribute($arg));
	    }
	    foreach my $child (@{children($step)}) {
		my $n = $child->type_name;
		if ($n eq 'sequential') {
		    runSteps($a,children($child),$args);
		} else {
		    printChild($child);
		}
	    }
	    print '</node>';
	} elsif ($name eq 'echo') {
	    my $text = $step->attribute("message");
	    my $children = $step->content_twine;
	    if (length(@$children) == 1 && length($children->[0] =~ s!^\s+!!r) > 0) {
		$text = $children->[0];
	    }
	    print '<node TEXT="echo ',xe($text),'">';
	    print '<icon BUILTIN="',$typeIcons{step},'"/>';
	    print '</node>';
	} else {
	    print '<node TEXT="',xe($name),'">';
	    print '<icon BUILTIN="',$typeIcons{step},'"/>';
	    foreach my $arg (keys %{$step->attributes}) {
		printArg($a,$args,$arg,$step->attribute($arg));
	    }
	    foreach my $child (@{children($step)}) {
		printChild($child);
	    }
	    my $macro = $a->{macros}->{$name};
	    if (defined($macro)) {
		my %args = map { $_ => expandArg($a, $args, $step->attribute($_)) } keys %{$step->attributes};
		runSteps($a, $macro->{steps}, \%args);
	    }
	    print '</node>';
	}
    }

    # TODO too late (if allowed at all) when executing targets
    foreach my $imp (@{$a->{imports}}) {
	merge($a, 'macros', $imp->{macros});
	merge($a, 'targets', $imp->{targets});
    }

    delete $a->{imports};
}

sub run($$);
sub run($$) {
    my ($a,$targetName) = @_;

    print '<node TEXT="',xe($targetName),'">';
    print '<icon BUILTIN="',$typeIcons{target},'"/>';

    my $target = $a->{targets}->{$targetName};
    if (defined($target->{deps})) {
	foreach my $dep (split(/,/, $target->{deps})) {
	    run($a, $dep);
	}
    }
    runSteps($a, $target->{steps}, undef);

    print '</node>';
}

print '<map version="1.0.1">';
print '<node TEXT="Execution tree">';
my $a = parse("wcs-build-all.xml", undef, {
#    'wcs.temp.deploy.dir' => '__wcs.temp.deploy.dir__'
});
run($a, 'full.content.rebuild.with.test.content');
print '<node POSITION="left" TEXT="Labels">';
foreach my $type (keys %typeIcons) {
    print '<node TEXT="',xe($type),'"><icon BUILTIN="',$typeIcons{$type},'"/></node>';
}
print '</node>';
print '</node>';
print "</map>\n";
